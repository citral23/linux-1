// SPDX-License-Identifier: GPL-2.0
/dts-v1/;

#include "jz4760b.dtsi"
#include <dt-bindings/clock/ingenic,tcu.h>

#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/iio/adc/ingenic,adc.h>
#include <dt-bindings/input/input.h>

#include <dt-bindings/interrupt-controller/irq.h>

/ {
	compatible = "ylm,x-game", "ingenic,jz4760b";
	model = "X-GAME";

	hdmi_power: regulator@2 {
		compatible = "regulator-fixed";
		regulator-name = "hdmi_pwr";
		gpio = <&gpb 6 0>;
		enable-active-high;

		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		vin-supply = <&vcc>;
	};

	hdmi-connector {
		compatible = "hdmi-connector";
		label = "hdmi";
		type = "a";

		port {
			hdmi_connector_in: endpoint {
				remote-endpoint = <&hdmi_connector_out>;
			};
		};
	};

	i2c2: i2c-controller@2 {
		status = "okay";

		compatible = "i2c-gpio";
		#address-cells = <1>;
		#size-cells = <0>;

		sda-gpios = <&gpd 30 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
		scl-gpios = <&gpd 31 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
		clock-frequency = <100000>; /* 100 kHz */

		it66121: hdmi@4c {
			compatible = "ite,it66121";
			reg = <0x4c>;

			interrupt-parent = <&gpe>;
			interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
			interrupt-names = "irq";

			reset-gpios = <&gpe 6 GPIO_ACTIVE_LOW>;

			pinctrl-names = "default";
			pinctrl-0 = <&pins_it66121>;

			vrf12-supply = <&hdmi_power>;
			vcn33-supply = <&hdmi_power>;
			vcn18-supply = <&hdmi_power>;

			ports {
				#address-cells = <1>;
				#size-cells = <0>;

				port@0 {
					reg = <0>;

					hdmi_input: endpoint {
						bus-width = <24>;
						remote-endpoint = <&hdmi_output>;
					};
				};

				port@1 {
					reg = <1>;

					hdmi_connector_out: endpoint {
						remote-endpoint = <&hdmi_connector_in>;
					};
				};
			};
		};
	};

	aliases {
		serial0 = &uart0;
		serial1 = &uart1;
		serial2 = &uart2;
		serial3 = &uart3;
	};

	memory: memory {
		device_type = "memory";
		reg = <0x0 0x8000000>;
	};

	chosen {
		stdout-path = "serial1:57600n8";
	};

	vcc: regulator@0 {
		compatible = "regulator-fixed";
		regulator-name = "vcc";

		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
	};

	mmc2_power: regulator@1 {
		compatible = "regulator-fixed";
		regulator-name = "mmc2_vcc";
		gpio = <&gpf 3 0>;

		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		vin-supply = <&vcc>;
	};

	/*
	audio_amp: analog-amplifier {
		compatible = "simple-audio-amplifier";
		enable-gpios = <&gpe 9 0>;
		enable-delay-ms = <50>;

		VCC-supply = <&vcc>;
	};

	sound_card: sound {
		compatible = "simple-audio-card";

		simple-audio-card,name = "lepus-audio";
		simple-audio-card,format = "i2s";

		simple-audio-card,widgets =
			"Speaker", "Speaker",
			"Headphone", "Headphones";
		simple-audio-card,routing =
			"Headphones", "LHPOUT",
			"Headphones", "RHPOUT",
			"INL", "LHPOUT",
			"INR", "RHPOUT",
			"Speaker", "OUTL",
			"Speaker", "OUTR";
		simple-audio-card,pin-switches = "Speaker";

		simple-audio-card,hp-det-gpio = <&gpd 6 GPIO_ACTIVE_LOW>;
		simple-audio-card,aux-devs = <&audio_amp>;

		simple-audio-card,bitclock-master = <&dai_codec>;
		simple-audio-card,frame-master = <&dai_codec>;

		dai_cpu: simple-audio-card,cpu {
			sound-dai = <&aic>;
		};

		dai_codec: simple-audio-card,codec {
			sound-dai = <&codec>;
		};
	};
	*/

	usb_conn: connector {
		compatible = "gpio-usb-a-connector", "usb-a-connector";
		label = "USB-A";

		port {
			usb_ep: endpoint {
				remote-endpoint = <&usb_otg_ep>;
			};
		};
	};

	cpu_opp_table: opp-table {
		compatible = "operating-points-v2";

		opp-528000000 { opp-hz = /bits/ 64 <528000000>; };
		opp-600000000 { opp-hz = /bits/ 64 <600000000>; };
		opp-612000000 { opp-hz = /bits/ 64 <612000000>; };
		opp-624000000 { opp-hz = /bits/ 64 <624000000>; };
		opp-636000000 { opp-hz = /bits/ 64 <636000000>; };
		opp-648000000 { opp-hz = /bits/ 64 <648000000>; };
		opp-660000000 { opp-hz = /bits/ 64 <660000000>; };
		opp-672000000 { opp-hz = /bits/ 64 <672000000>; };
		opp-684000000 { opp-hz = /bits/ 64 <684000000>; };
		opp-696000000 { opp-hz = /bits/ 64 <696000000>; };
		opp-708000000 { opp-hz = /bits/ 64 <708000000>; };
		opp-720000000 { opp-hz = /bits/ 64 <720000000>; };
		opp-732000000 { opp-hz = /bits/ 64 <732000000>; };
		opp-744000000 { opp-hz = /bits/ 64 <744000000>; };
		opp-756000000 { opp-hz = /bits/ 64 <756000000>; };
		opp-768000000 { opp-hz = /bits/ 64 <768000000>; };
		opp-780000000 { opp-hz = /bits/ 64 <780000000>; };
	};
};

&cpu0 {
	operating-points-v2 = <&cpu_opp_table>;

	/* We use the main PLL as the CPU clock for the cpufreq driver. */
	clocks = <&cgu JZ4760_CLK_PLL0>;
};

&ext {
	clock-frequency = <12000000>;
};

&pinctrl {
	pins_lcd: lcd {
		function = "lcd";
		groups = "lcd-8bit", "lcd-16bit", "lcd-18bit", "lcd-24bit", "lcd-generic";
	};

	pins_uart1: uart1 {
		function = "uart1";
		groups = "uart1-data";
	};

	pins_mmc0: mmc0 {
		function = "mmc0";
		groups = "mmc0-1bit-a", "mmc0-4bit-a";
	};

	pins_mmc2: mmc2 {
		function = "mmc2";
		groups = "mmc2-1bit-e", "mmc2-4bit-e";
	};

	pins_it66121: it66121 {
		pins = "PE12";
		bias-pull-up;
	};
};

&uart1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pins_uart1>;

	status = "okay";
};

&cgu {
	/*
	 * Put high-speed peripherals under PLL1, such that we can change the
	 * PLL0 frequency on demand without having to suspend peripherals.
	 * We use a rate of 432 MHz, which is the least common multiple of
	 * 27 MHz (required by TV encoder) and 48 MHz (required by USB host).
	 * Use the 32 kHz oscillator as the parent of the RTC for a higher
	 * precision.
	 */
	assigned-clocks =
		<&cgu JZ4760_CLK_PLL1>,
		<&cgu JZ4760_CLK_PLL0_HALF>,
		<&cgu JZ4760_CLK_MMC_MUX>,
		<&cgu JZ4760_CLK_RTC>,
		<&cgu JZ4760_CLK_UHC>,
		<&cgu JZ4760_CLK_LPCLK_DIV>;
	assigned-clock-parents =
		<0>,
		<0>,
		<&cgu JZ4760_CLK_PLL0_HALF>,
		<&cgu JZ4760_CLK_OSC32K>,
		<&cgu JZ4760_CLK_PLL1>,
		<&cgu JZ4760_CLK_PLL1>;
	assigned-clock-rates =
		<432000000>, <600000000>, <50000000>;
};

&tcu {
	/*
	 * 750 kHz for the system timer and clocksource, 12 MHz for the OST,
	 * and use RTC as the parent for the watchdog clock
	 */
	assigned-clocks = <&tcu TCU_CLK_TIMER0>, <&tcu TCU_CLK_TIMER2>,
			  <&tcu TCU_CLK_OST>, <&tcu TCU_CLK_WDT>;
	assigned-clock-parents = <0>, <0>, <0>, <&cgu JZ4760_CLK_RTC>;
	assigned-clock-rates = <750000>, <750000>, <12000000>;

	/* PWM1 is in use, so use channel #2 for the clocksource */
	ingenic,pwm-channels-mask = <0xfa>;
};

&usb_otg {
	dr_mode = "host";
	port {
		usb_otg_ep: endpoint {
			remote-endpoint = <&usb_ep>;
		};
	};
};

&otg_phy {
	vcc-supply = <&vcc>;
};

&rtc {
	clocks = <&cgu JZ4760_CLK_RTC>;
	clock-names = "rtc";

	system-power-controller;

	ingenic,reset-pin-assert-time-ms = <125>;
	ingenic,min-wakeup-pin-assert-time-ms = <500>;
};

&mmc0 {
	status = "okay";

	bus-width = <4>;
	max-frequency = <50000000>;
	vmmc-supply = <&vcc>;
	non-removable;

	pinctrl-names = "default";
	pinctrl-0 = <&pins_mmc0>;
};

&mmc2 {
	status = "okay";

	bus-width = <4>;
	max-frequency = <50000000>;
	cd-gpios = <&gpf 0 GPIO_ACTIVE_LOW>;
	vmmc-supply = <&mmc2_power>;

	pinctrl-names = "default";
	pinctrl-0 = <&pins_mmc2>;
};

&lcd {
	pinctrl-names = "default";
	pinctrl-0 = <&pins_lcd>;

	ports {
		#address-cells = <1>;
		#size-cells = <0>;

		port@0 {
			reg = <0>;

			hdmi_output: endpoint {
				remote-endpoint = <&hdmi_input>;
			};
		};

		port@8 {
			reg = <8>;

			ipu_output: endpoint {
				remote-endpoint = <&ipu_input>;
			};
		};
	};
};

&ipu {
	port {
		ipu_input: endpoint {
			remote-endpoint = <&ipu_output>;
		};
	};
};
