// SPDX-License-Identifier: GPL-2.0
/dts-v1/;

#include "jz4760b.dtsi"
#include <dt-bindings/clock/ingenic,tcu.h>

#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/iio/adc/ingenic,adc.h>
#include <dt-bindings/input/input.h>

#include <dt-bindings/interrupt-controller/irq.h>

/ {
	compatible = "ylm,x-game", "ingenic,jz4760b";
	model = "X-GAME";

	hdmi_power: regulator@2 {
		compatible = "regulator-fixed";
		regulator-name = "hdmi_pwr";
		gpio = <&gpb 6 0>;
		enable-active-high;

		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		vin-supply = <&vcc>;
	};

	hdmi-connector {
		compatible = "hdmi-connector";
		label = "hdmi";
		type = "a";

		port {
			hdmi_connector_in: endpoint {
				remote-endpoint = <&hdmi_connector_out>;
			};
		};
	};

	i2c2: i2c-controller@2 {
		status = "okay";

		compatible = "i2c-gpio";
		#address-cells = <1>;
		#size-cells = <0>;

		sda-gpios = <&gpd 30 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
		scl-gpios = <&gpd 31 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
		clock-frequency = <100000>; /* 100 kHz */

		it66121: hdmi@4c {
			compatible = "ite,it66121";
			reg = <0x4c>;

			interrupt-parent = <&gpe>;
			interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
			interrupt-names = "irq";

			reset-gpios = <&gpe 6 GPIO_ACTIVE_LOW>;

			pinctrl-names = "default";
			pinctrl-0 = <&pins_it66121>;

			vrf12-supply = <&hdmi_power>;
			vcn33-supply = <&hdmi_power>;
			vcn18-supply = <&hdmi_power>;

			ports {
				#address-cells = <1>;
				#size-cells = <0>;

				port@0 {
					reg = <0>;

					hdmi_input: endpoint {
						bus-width = <24>;
						remote-endpoint = <&hdmi_output>;
					};
				};

				port@1 {
					reg = <1>;

					hdmi_connector_out: endpoint {
						remote-endpoint = <&hdmi_connector_in>;
					};
				};
			};
		};
	};

	aliases {
		serial0 = &uart0;
		serial1 = &uart1;
		serial2 = &uart2;
		serial3 = &uart3;
	};

	memory: memory {
		device_type = "memory";
		reg = <0x0 0x8000000>;
	};

	chosen {
		stdout-path = "serial1:57600n8";
	};

	vcc: regulator@0 {
		compatible = "regulator-fixed";
		regulator-name = "vcc";

		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
	};

	mmc2_power: regulator@1 {
		compatible = "regulator-fixed";
		regulator-name = "mmc2_vcc";
		gpio = <&gpf 3 0>;

		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		vin-supply = <&vcc>;
	};

	usb_conn: connector {
		compatible = "gpio-usb-a-connector", "usb-a-connector";
		label = "USB-A";

		port {
			usb_ep: endpoint {
				remote-endpoint = <&usb_otg_ep>;
			};
		};
	};

	cpu_opp_table: opp-table {
		compatible = "operating-points-v2";

		opp-480000000 { opp-hz = /bits/ 64 <480000000>; };
		opp-528000000 { opp-hz = /bits/ 64 <528000000>; };
		opp-576000000 { opp-hz = /bits/ 64 <576000000>; };
		opp-624000000 { opp-hz = /bits/ 64 <624000000>; };
		opp-672000000 { opp-hz = /bits/ 64 <672000000>; };
		opp-720000000 { opp-hz = /bits/ 64 <720000000>; };
		opp-768000000 { opp-hz = /bits/ 64 <768000000>; };
		opp-816000000 { opp-hz = /bits/ 64 <816000000>; };
		opp-864000000 { opp-hz = /bits/ 64 <864000000>; };
		opp-912000000 { opp-hz = /bits/ 64 <912000000>; };
		opp-960000000 { opp-hz = /bits/ 64 <960000000>; };
		opp-1008000000 { opp-hz = /bits/ 64 <1008000000>; };
		opp-1056000000 { opp-hz = /bits/ 64 <1056000000>; };
		opp-1104000000 { opp-hz = /bits/ 64 <1104000000>; };
		opp-1152000000 { opp-hz = /bits/ 64 <1152000000>; };
		opp-1200000000 { opp-hz = /bits/ 64 <1200000000>; };
		opp-1248000000 { opp-hz = /bits/ 64 <1248000000>; };
		opp-1296000000 { opp-hz = /bits/ 64 <1296000000>; };
		opp-1344000000 { opp-hz = /bits/ 64 <1344000000>; };
		opp-1392000000 { opp-hz = /bits/ 64 <1392000000>; };
		opp-1440000000 { opp-hz = /bits/ 64 <1440000000>; };
		opp-1488000000 { opp-hz = /bits/ 64 <1488000000>; };
		opp-1536000000 { opp-hz = /bits/ 64 <1536000000>; };
		opp-1584000000 { opp-hz = /bits/ 64 <1584000000>; };

	};
};

&cpu0 {
	operating-points-v2 = <&cpu_opp_table>;

	/* We use the main PLL as the CPU clock for the cpufreq driver. */
	clocks = <&cgu JZ4760_CLK_PLL0>;
};

&ext {
	clock-frequency = <12000000>;
};

&pinctrl {
	pins_lcd: lcd {
		function = "lcd";
		groups = "lcd-8bit", "lcd-16bit", "lcd-18bit", "lcd-24bit", "lcd-generic";
	};

	pins_uart1: uart1 {
		function = "uart1";
		groups = "uart1-data";
	};

	pins_mmc0: mmc0 {
		function = "mmc0";
		groups = "mmc0-1bit-a", "mmc0-4bit-a";
	};

	pins_mmc2: mmc2 {
		function = "mmc2";
		groups = "mmc2-1bit-e", "mmc2-4bit-e";
	};

	pins_it66121: it66121 {
		pins = "PE12";
		bias-pull-up;
	};
};

&uart1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pins_uart1>;

	status = "okay";
};

&cgu {
	/*
	 * Put high-speed peripherals under PLL1, such that we can change the
	 * PLL0 frequency on demand without having to suspend peripherals.
	 * We use a rate of 432 MHz, which is the least common multiple of
	 * 27 MHz (required by TV encoder) and 48 MHz (required by USB host).
	 * Use the 32 kHz oscillator as the parent of the RTC for a higher
	 * precision.
	 */
	assigned-clocks =
		<&cgu JZ4760_CLK_PLL1>,
		<&cgu JZ4760_CLK_PLL0_HALF>,
		<&cgu JZ4760_CLK_MMC_MUX>,
		<&cgu JZ4760_CLK_RTC>,
		<&cgu JZ4760_CLK_UHC>,
		<&cgu JZ4760_CLK_LPCLK_DIV>;
	assigned-clock-parents =
		<0>,
		<0>,
		<&cgu JZ4760_CLK_PLL0_HALF>,
		<&cgu JZ4760_CLK_OSC32K>,
		<&cgu JZ4760_CLK_PLL1>,
		<&cgu JZ4760_CLK_PLL1>;
	assigned-clock-rates =
		<432000000>, <600000000>, <25000000>;
};

&tcu {
	/*
	 * 750 kHz for the system timer and clocksource, 12 MHz for the OST,
	 * and use RTC as the parent for the watchdog clock
	 */
	assigned-clocks = <&tcu TCU_CLK_TIMER0>, <&tcu TCU_CLK_TIMER2>,
			  <&tcu TCU_CLK_OST>, <&tcu TCU_CLK_WDT>;
	assigned-clock-parents = <0>, <0>, <0>, <&cgu JZ4760_CLK_RTC>;
	assigned-clock-rates = <750000>, <750000>, <12000000>;

	/* PWM1 is in use, so use channel #2 for the clocksource */
	ingenic,pwm-channels-mask = <0xfa>;
};

&usb_otg {
	dr_mode = "host";
	port {
		usb_otg_ep: endpoint {
			remote-endpoint = <&usb_ep>;
		};
	};
};

&otg_phy {
	vcc-supply = <&vcc>;
};

&rtc {
	clocks = <&cgu JZ4760_CLK_RTC>;
	clock-names = "rtc";

	system-power-controller;

	ingenic,reset-pin-assert-time-ms = <125>;
	ingenic,min-wakeup-pin-assert-time-ms = <500>;
};

&mmc0 {
	status = "okay";

	bus-width = <4>;
	max-frequency = <25000000>;
	vmmc-supply = <&vcc>;
	non-removable;

	pinctrl-names = "default";
	pinctrl-0 = <&pins_mmc0>;
};

&mmc2 {
	status = "okay";

	bus-width = <4>;
	max-frequency = <25000000>;
	cd-gpios = <&gpf 0 GPIO_ACTIVE_LOW>;
	vmmc-supply = <&mmc2_power>;

	pinctrl-names = "default";
	pinctrl-0 = <&pins_mmc2>;
};

&lcd {
	pinctrl-names = "default";
	pinctrl-0 = <&pins_lcd>;

	ports {
		#address-cells = <1>;
		#size-cells = <0>;

		port@0 {
			reg = <0>;

			hdmi_output: endpoint {
				remote-endpoint = <&hdmi_input>;
			};
		};

		port@8 {
			reg = <8>;

			ipu_output: endpoint {
				remote-endpoint = <&ipu_input>;
			};
		};
	};
};

&ipu {
	port {
		ipu_input: endpoint {
			remote-endpoint = <&ipu_output>;
		};
	};
};
